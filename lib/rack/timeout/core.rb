# encoding: utf-8

require 'securerandom'
require_relative 'support/monotonic_time'
require_relative 'support/scheduler'
require_relative 'support/timeout'

module Rack
  class Timeout
    include Rack::Timeout::MonotonicTime # gets us the #fsecs method

    # Shared by the following exceptions, allows them to receive the current env
    module ExceptionWithEnv
      attr_reader :env
      def initialize(env)
        @env = env
      end
    end

    class Error < RuntimeError
      include ExceptionWithEnv
    end

    # Raised when a request has run for too long
    class RequestTimeoutError < Error; end

    # This is first raised to help prevent an application from inadvertently catching the above.
    # It's then caught by rack-timeout and replaced with RequestTimeoutError to bubble up to
    # wrapping middlewares and the web server
    class RequestTimeoutException < Exception
      include ExceptionWithEnv
    end

    RequestDetails = Struct.new(
      :id,        # a unique identifier for the request. informative-only.
      :wait,      # seconds the request spent in the web server before being serviced by rack
      :service,   # time rack spent processing the request (updated ~ every second)
      :timeout,   # the actual computed timeout to be used for this request
      :state,     # the request's current state, see VALID_STATES below
    ) {
      # helper method used for formatting values in milliseconds
      def ms(k)
        '%.fms' % (self[k] * 1000) if self[k]
      end
    }
    VALID_STATES = [
      :expired,   # The request was too old by the time it reached rack (see wait_timeout, wait_overtime)
      :ready,     # We're about to start processing this request
      :active,    # This request is currently being handled
      :timed_out, # This request has run for too long and we're raising a timeout error in it
      :completed, # We're done with this request (also set after having timed out a request)
    ].freeze

    # key under which each request's RequestDetails instance is stored in its env.
    ENV_INFO_KEY = 'rack-timeout.info'.freeze

    # key where request id is stored if generated by upstream client/proxy
    HTTP_X_REQUEST_ID = 'HTTP_X_REQUEST_ID'.freeze

    # key where request id is stored if generated by action dispatch
    ACTION_DISPATCH_REQUEST_ID = 'action_dispatch.request_id'.freeze

    # Helper methods to read timeout properties. Ensure they're always positive numbers or false.
    # When set to false (or 0), their behaviour is disabled.
    def read_timeout_property value, default
      case value
      when nil   ; read_timeout_property default, default
      when false ; false
      when 0     ; false
      else
        if value.is_a?(Numeric) && value > 0 or value.respond_to?(:call)
          value
        else
          raise(
            ArgumentError,
            "value #{value.inspect} should be false, zero, a positive number or a block returning a positive number."
          )
        end
      end
    end

    # How long the application can take to complete handling the request once it's passed down to it.
    attr_reader :service_timeout

    def initialize(app, service_timeout: nil)
      @service_timeout = read_timeout_property service_timeout, ENV.fetch('RACK_TIMEOUT_SERVICE_TIMEOUT', 15).to_i
      @app = app
    end

    RT = self # shorthand reference
    def call(env)
      info = (env[ENV_INFO_KEY] ||= RequestDetails.new)
      info.id ||= env[HTTP_X_REQUEST_ID] || env[ACTION_DISPATCH_REQUEST_ID] || SecureRandom.uuid

      ts_started_service = fsecs # The monotonic time the request started being processed by rack

      # pass request through if service_timeout is false (i.e., don't time it out at all.)
      return @app.call(env) unless service_timeout

      # Compute actual timeout to be used for this request
      info.timeout = service_timeout.respond_to?(:call) ? service_timeout.call(env) : service_timeout

      RT._set_state! env, :ready                      # we're good to go, but have done nothing yet

      heartbeat_event = nil                           # init var so it's in scope for following proc
      register_state_change = ->(status = :active) {  # updates service time and state; will run every second
        heartbeat_event.cancel! if status != :active  # if the request is no longer active we should stop updating
        info.service = fsecs - ts_started_service     # update service time
        RT._set_state! env, status                    # update status
      }

      # start updating every second while active; if log level is debug, this will log every sec
      heartbeat_event = RT::Scheduler.run_every(1) { register_state_change.call :active }

      # creates a timeout instance responsible for timing out the request. the given block runs if timed out
      timeout = RT::Scheduler::Timeout.new do |app_thread|
        register_state_change.call :timed_out
        app_thread.raise(
          RequestTimeoutException.new(env),
          "Request #{"waited #{info.ms(:wait)}, then " if info.wait}ran for longer than #{info.ms(:timeout)}"
        )
      end

      response = timeout.timeout(info.timeout) do     # perform request with timeout
        begin
          # boom, send request down the middleware chain
          @app.call(env)
        rescue RequestTimeoutException => e
          # will actually hardly ever get to this point because frameworks tend to catch this. see README for more
          # but in case it does get here, re-raise RequestTimeoutException as RequestTimeoutError
          raise RequestTimeoutError.new(env), e.message, e.backtrace
        ensure
          register_state_change.call :completed
        end
      end

      response
    end

    ###
    # following methods are used internally (called by instances, so can't be private.
    # _ marker should discourage people from calling them)

    def self._set_state!(env, state)
      raise "Invalid state: #{state.inspect}" unless VALID_STATES.include? state

      env[ENV_INFO_KEY].state = state
      notify_state_change_observers(env)
    end

    ### state change notification-related methods
    @state_change_observers = {}

    # Registers a block to be called back when a request changes state in rack-timeout.
    # The block will receive the request's env.
    #
    # `id` is anything that uniquely identifies this particular callback,
    # mostly so it may be removed via `unregister_state_change_observer`.
    def self.register_state_change_observer(id, &callback)
      raise "An observer with the id #{id.inspect} is already set." if @state_change_observers.key? id
      raise ArgumentError, 'A callback block is required.' unless callback

      @state_change_observers[id] = callback
    end

    # Removes the observer with the given id
    def self.unregister_state_change_observer(id)
      @state_change_observers.delete(id)
    end

    # Sends out the notifications. Called internally at the end of `_set_state!`
    def self.notify_state_change_observers(env)
      @state_change_observers.values.each { |observer| observer.call(env) }
    end
    private_class_method :notify_state_change_observers
  end
end
